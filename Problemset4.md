# ğŸ¯ BirleÅŸik Teknik Analiz: Problem Set 4

> **Merge Sort Implementasyonu & LeetCode Problemleri**  
> Bu dokÃ¼man, Merge Sort algoritmasÄ± ile LeetCode'un "Search Insert Position" ve "Palindrome Number" problemlerinin detaylÄ± teknik analizini iÃ§erir.

---

## ğŸ”„ Problem 1: Merge Sort (BirleÅŸtirmeli SÄ±ralama)

### â“ GÃ¶rev (Aufgabe 1)

**Hedef:** `Main.java` sÄ±nÄ±fÄ±ndaki `merge` ve `mergesort` fonksiyonlarÄ±nÄ± tamamlayarak Merge Sort algoritmasÄ±nÄ± implement edin.

### ğŸ§  Algoritma MantÄ±ÄŸÄ±

```
Merge Sort = BÃ¶l ve Fethet (Divide & Conquer)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. BÃ–L (Divide)                           â”‚
â”‚     â””â”€ Diziyi ikiye bÃ¶l                    â”‚
â”‚     â””â”€ Her bÃ¶lÃ¼mÃ¼ tek eleman kalana kadar  â”‚
â”‚                                             â”‚
â”‚  2. FETHET (Conquer)                       â”‚
â”‚     â””â”€ SÄ±ralÄ± alt dizileri birleÅŸtir       â”‚
â”‚     â””â”€ SonuÃ§: Tamamen sÄ±ralÄ± dizi          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ¬ GÃ¶rsel GÃ¶sterim

```
Orijinal Dizi: [38, 27, 43, 3, 9, 82, 10]

         [38, 27, 43, 3, 9, 82, 10]
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                       â”‚
    [38, 27, 43, 3]        [9, 82, 10]
        â”‚                       â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚       â”‚              â”‚         â”‚
[38, 27] [43, 3]        [9, 82]    [10]
    â”‚       â”‚              â”‚         â”‚
  â”Œâ”€â”´â”€â”   â”Œâ”€â”´â”€â”         â”Œâ”€â”€â”´â”€â”€â”     â”‚
  â”‚   â”‚   â”‚   â”‚         â”‚     â”‚     â”‚
[38] [27] [43] [3]     [9]  [82]  [10]
  â”‚   â”‚   â”‚   â”‚         â”‚     â”‚     â”‚
  â””â”€â”¬â”€â”˜   â””â”€â”¬â”€â”˜         â””â”€â”€â”¬â”€â”€â”˜     â”‚
    â”‚       â”‚              â”‚         â”‚
[27, 38] [3, 43]        [9, 82]   [10]
    â”‚       â”‚              â”‚         â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”‚                       â”‚
  [3, 27, 38, 43]        [9, 10, 82]
        â”‚                       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        [3, 9, 10, 27, 38, 43, 82]

ğŸ¯ BÃ–LDÃœK (â†“)  â†’  BÄ°RLEÅTÄ°RDÄ°K (â†‘)
```

---

### âœ¨ Ã‡Ã¶zÃ¼m Analizi

#### ğŸ“ `mergesort(int[] A)` Fonksiyonu

```java
public static int[] mergesort(int[] A) {
    // âš¡ 1. Temel Durum (Base Case)
    if(A.length == 1) {
        return A;  // Tek elemanlÄ± dizi zaten sÄ±ralÄ±!
    }
    
    // ğŸ“ 2. Orta noktayÄ± bul
    int mid = A.length / 2;
    int[] left = new int[mid];
    int[] right = new int[A.length - mid];

    // ğŸ“¦ 3. Diziyi ikiye kopyala
    for(int i = 0; i < left.length; i++) {
        left[i] = A[i];
    }
    for(int i = mid; i < A.length; i++) {
        right[i - mid] = A[i];
    }
    
    // ğŸ”„ 4. Ã–zyineli olarak "BÃ¶l"
    left = mergesort(left);
    right = mergesort(right);
    
    // ğŸ”— 5. "BirleÅŸtir" ve dÃ¶ndÃ¼r
    return merge(left, right);
}
```

#### ğŸ” AdÄ±m AdÄ±m Analiz

```
Ã–zyineleme AÄŸacÄ± (N=8 iÃ§in):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Seviye 0:  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]           1 Ã§aÄŸrÄ±
               â”‚
Seviye 1:  [â–ˆâ–ˆâ–ˆâ–ˆ] [â–ˆâ–ˆâ–ˆâ–ˆ]        2 Ã§aÄŸrÄ±
               â”‚     â”‚
Seviye 2:  [â–ˆâ–ˆ][â–ˆâ–ˆ][â–ˆâ–ˆ][â–ˆâ–ˆ]     4 Ã§aÄŸrÄ±
               â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
Seviye 3:  [â–ˆ][â–ˆ][â–ˆ][â–ˆ][â–ˆ][â–ˆ]   8 Ã§aÄŸrÄ±

Toplam Seviye: logâ‚‚(8) = 3
Her seviyede: O(N) iÅŸlem
Toplam: O(N log N) âœ¨
```

---

#### ğŸ“ `merge(int[] A, int[] B)` Fonksiyonu

```java
public static int[] merge(int[] A, int B[]) {
    int[] C = new int[A.length + B.length];  // SonuÃ§ dizisi
    int i = 0, j = 0, k = 0;  // ÃœÃ§ sayaÃ§ (three-pointer)
    
    // ğŸ”„ 1. Ana KarÅŸÄ±laÅŸtÄ±rma DÃ¶ngÃ¼sÃ¼
    while(i < A.length && j < B.length) {
        if(A[i] <= B[j]) {
            C[k++] = A[i++];  // A'dan al
        }
        else {
            C[k++] = B[j++];  // B'den al
        }
    }
    
    // ğŸ“ 2. Kalan elemanlarÄ± kopyala
    while(i < A.length) {
        C[k++] = A[i++];
    }
    while(j < B.length) {
        C[k++] = B[j++];
    }
    
    return C;
}
```

#### ğŸ¯ Merge Ä°ÅŸlemi Ã–rneÄŸi

```
A = [3, 27, 38, 43]    B = [9, 10, 82]
     â†‘                      â†‘
     i                      j

AdÄ±m AdÄ±m:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”‚ AdÄ±m â”‚  A[i] â”‚  B[j] â”‚ KarÅŸÄ±laÅŸtÄ±rma â”‚  C   â”‚
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”‚  1   â”‚   3   â”‚   9   â”‚   3 < 9       â”‚ [3]  â”‚
â”‚  2   â”‚  27   â”‚   9   â”‚  27 > 9       â”‚ [3,9]â”‚
â”‚  3   â”‚  27   â”‚  10   â”‚  27 > 10      â”‚[3,9,10]â”‚
â”‚  4   â”‚  27   â”‚  82   â”‚  27 < 82      â”‚[3,9,10,27]â”‚
â”‚  5   â”‚  38   â”‚  82   â”‚  38 < 82      â”‚[3,9,10,27,38]â”‚
â”‚  6   â”‚  43   â”‚  82   â”‚  43 < 82      â”‚[3,9,10,27,38,43]â”‚
â”‚  7   â”‚   -   â”‚  82   â”‚  B kaldÄ±      â”‚[3,9,10,27,38,43,82]â”‚
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SonuÃ§: [3, 9, 10, 27, 38, 43, 82] âœ…
```

---

### ğŸ“ˆ KarmaÅŸÄ±klÄ±k Analizi

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â±ï¸  Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±: O(N log N)         â”‚
â”‚                                             â”‚
â”‚     â€¢ BÃ¶lme seviyesi: log N                â”‚
â”‚     â€¢ Her seviyede merge: N iÅŸlem          â”‚
â”‚     â€¢ Toplam: N Ã— log N                    â”‚
â”‚                                             â”‚
â”‚     Ã–rnek (N=1000):                        â”‚
â”‚     â€¢ Seviye sayÄ±sÄ±: ~10                   â”‚
â”‚     â€¢ Ä°ÅŸlem: 1000 Ã— 10 = 10,000 âš¡         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¾ Alan KarmaÅŸÄ±klÄ±ÄŸÄ±: O(N)                 â”‚
â”‚                                             â”‚
â”‚     â€¢ Her merge'de yeni dizi (C)           â”‚
â”‚     â€¢ Ã–zyineli Ã§aÄŸrÄ±larda left/right       â”‚
â”‚     â€¢ In-place DEÄÄ°L âš ï¸                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### âš¡ Performans KarÅŸÄ±laÅŸtÄ±rmasÄ±

```
                N=10,000 iÃ§in
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Bubble Sort:    100,000,000  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Selection:       50,000,000  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Merge Sort:         140,000  â–ˆ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
              ~700x daha hÄ±zlÄ±! ğŸš€
```

---

## ğŸ” Problem 2: Search Insert Position (#35)

### â“ Problem TanÄ±mÄ±

**GÃ¶rev:** SÄ±ralÄ± bir `nums` dizisi ve `target` deÄŸeri veriliyor:
1. `target` varsa â†’ indeksini dÃ¶ndÃ¼r
2. `target` yoksa â†’ eklenmesi gereken indeksi dÃ¶ndÃ¼r
3. **Zorunluluk:** O(log N) karmaÅŸÄ±klÄ±kta Ã§Ã¶z!

### ğŸ’¡ Ã–rnekler

```
Ã–rnek 1:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Girdi:  nums = [1, 3, 5, 6], target = 5
Ã‡Ä±ktÄ±:  2
AÃ§Ä±klama: 5 dizide var, indeksi 2

Ã–rnek 2:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Girdi:  nums = [1, 3, 5, 6], target = 2
Ã‡Ä±ktÄ±:  1
AÃ§Ä±klama: 2 yok, [1, ğŸ‘‰2, 3, 5, 6]

Ã–rnek 3:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Girdi:  nums = [1, 3, 5, 6], target = 7
Ã‡Ä±ktÄ±:  4
AÃ§Ä±klama: 7 yok, [1, 3, 5, 6, ğŸ‘‰7]
```

---

### âœ¨ Ã‡Ã¶zÃ¼m Analizi

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        
        while(left <= right) {
            // âš ï¸ Overflow-safe orta nokta hesabÄ±
            int mid = left + (right - left) / 2;
            
            if(nums[mid] == target) {
                return mid;  // ğŸ¯ Bulundu!
            }
            else if(nums[mid] < target) {
                left = mid + 1;  // â¡ï¸ SaÄŸa git
            }
            else {
                right = mid - 1;  // â¬…ï¸ Sola git
            }
        }
        
        return left;  // ğŸ”‘ Kritik: Insert pozisyonu
    }
};
```

### ğŸ¬ Binary Search GÃ¶rselleÅŸtirmesi

```
nums = [1, 3, 5, 6], target = 2

Ä°terasyon 1:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[1,  3,  5,  6]
 â†‘      â†‘      â†‘
left   mid   right

mid = (0+3)/2 = 1  â†’  nums[1] = 3
3 > 2  â†’  Sola git!  â†’  right = mid-1 = 0

Ä°terasyon 2:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[1,  3,  5,  6]
 â†‘
left
mid
right

mid = (0+0)/2 = 0  â†’  nums[0] = 1
1 < 2  â†’  SaÄŸa git!  â†’  left = mid+1 = 1

DÃ¶ngÃ¼ Biter:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
left > right  â†’  (1 > 0)
return left = 1  âœ…

SonuÃ§: [1, ğŸ‘‰2, 3, 5, 6]
```

### ğŸ”‘ Neden `return left;` Ã‡alÄ±ÅŸÄ±r?

```
DÃ¶ngÃ¼ BittiÄŸinde:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Durum 1: Target Bulundu
  â”œâ”€ nums[mid] == target
  â””â”€ return mid (zaten dÃ¶ndÃ¼)

Durum 2: Target BulunamadÄ±
  â”œâ”€ left > right oldu
  â”œâ”€ left, target'Ä±n olmasÄ± gereken yeri gÃ¶sterir
  â””â”€ Neden? Ä°kili arama sÄ±ralÄ± dizide pozisyonu bulur!

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  left her zaman target'Ä±n               â”‚
â”‚  eklenmesi gereken pozisyonu gÃ¶sterir   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ¯ Kritik: Overflow-Safe Orta Nokta

```
âŒ Tehlikeli:  mid = (left + right) / 2
   Problem: left + right > INT_MAX overflow!

âœ… GÃ¼venli:   mid = left + (right - left) / 2
   Neden: (right - left) her zaman kÃ¼Ã§Ã¼k kalÄ±r
   
Ã–rnek:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
left = 2,000,000,000
right = 2,000,000,100

âŒ (left + right) / 2 
   = 4,000,000,100 / 2  â†’ OVERFLOW! ğŸ’¥

âœ… left + (right - left) / 2
   = 2,000,000,000 + 100/2
   = 2,000,000,050 âœ“
```

---

### ğŸ“ˆ KarmaÅŸÄ±klÄ±k Analizi

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â±ï¸  Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±: O(log N)           â”‚
â”‚                                             â”‚
â”‚     Her adÄ±mda arama alanÄ± yarÄ±ya iner:    â”‚
â”‚     N â†’ N/2 â†’ N/4 â†’ ... â†’ 1               â”‚
â”‚                                             â”‚
â”‚     Ã–rnek (N=1,000,000):                   â”‚
â”‚     â€¢ Maksimum adÄ±m: logâ‚‚(1M) â‰ˆ 20 ğŸš€      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¾ Alan KarmaÅŸÄ±klÄ±ÄŸÄ±: O(1)                 â”‚
â”‚                                             â”‚
â”‚     â€¢ Sadece 3 deÄŸiÅŸken (left, right, mid) â”‚
â”‚     â€¢ Ekstra dizi yok                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ Problem 3: Palindrome Number (#9)

### â“ Problem TanÄ±mÄ±

**GÃ¶rev:** Bir tamsayÄ±nÄ±n palindrom olup olmadÄ±ÄŸÄ±nÄ± kontrol et.

**Palindrom:** Soldan saÄŸa = SaÄŸdan sola

```
âœ… Palindrom Ã–rnekleri:
   121   â†’  121  (aynÄ±)
   1221  â†’  1221 (aynÄ±)
   0     â†’  0    (aynÄ±)

âŒ Palindrom Olmayan:
   -121  â†’  121- (farklÄ±, - sonda)
   10    â†’  01   (farklÄ±, 0 baÅŸta)
   123   â†’  321  (farklÄ±)
```

### ğŸ¯ Follow-Up Challenge

> String'e dÃ¶nÃ¼ÅŸtÃ¼rmeden Ã§Ã¶zebilir misin? ğŸ¤”

---

### âœ¨ Ã‡Ã¶zÃ¼m Analizi (String YaklaÅŸÄ±mÄ±)

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        // ğŸ“ 1. String'e dÃ¶nÃ¼ÅŸtÃ¼r
        string str = to_string(x);
        
        // âŒ 2. Negatif kontrolÃ¼ (akÄ±llÄ±ca!)
        if(str[0] == '-') {
            return false;
        }

        // ğŸ“ 3. Orta nokta
        float mid = str.size() / 2;
        
        // ğŸ”„ 4. Ä°ki uÃ§tan karÅŸÄ±laÅŸtÄ±r
        for(int i = 0; i < mid; i++) {
            if(str[i] != str[str.size() - i - 1]) {
                return false;
            }
        }
        
        return true;
    }
};
```

### ğŸ¬ GÃ¶rsel GÃ¶sterim

```
Ã–rnek: x = 12321

1. String'e DÃ¶nÃ¼ÅŸÃ¼m:
   12321  â†’  "12321"

2. Ä°ki UÃ§lu KarÅŸÄ±laÅŸtÄ±rma:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  1  2  3  2  1     â”‚
   â”‚  â†‘     â†“     â†‘     â”‚
   â”‚  â””â”€â”€â”€â”€â”€âœ“â”€â”€â”€â”€â”€â”˜     â”‚
   â”‚     â†‘  â†“  â†‘        â”‚
   â”‚     â””â”€â”€âœ“â”€â”€â”˜        â”‚
   â”‚        â†“           â”‚
   â”‚        âœ“           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   
TÃ¼m karÅŸÄ±laÅŸtÄ±rmalar eÅŸit â†’ true âœ…

Ã–rnek: x = 123

   1  2  3
   â†‘     â†‘
   â””â”€â”€âŒâ”€â”˜
   
1 â‰  3 â†’ false âŒ
```

### ğŸ¯ DetaylÄ± AdÄ±m Analizi

```
x = 1221 iÃ§in:

str = "1221"
mid = 4/2 = 2

Ä°terasyon Tablosu:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”‚  i  â”‚ str[i] â”‚ str[4-i-1] â”‚ KarÅŸÄ±laÅŸtÄ±rma â”‚
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”‚  0  â”‚   '1'  â”‚   '1'      â”‚   âœ“ EÅŸit     â”‚
â”‚  1  â”‚   '2'  â”‚   '2'      â”‚   âœ“ EÅŸit     â”‚
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SonuÃ§: true âœ…
```

---

### ğŸ’¡ Alternatif Ã‡Ã¶zÃ¼m (String'siz)

```cpp
// ğŸš€ Follow-up Ã§Ã¶zÃ¼mÃ¼: String kullanmadan!
bool isPalindrome(int x) {
    // Negatif sayÄ±lar palindrom olamaz
    if(x < 0) return false;
    
    // SayÄ±nÄ±n tersini oluÅŸtur
    int original = x;
    long reversed = 0;
    
    while(x > 0) {
        reversed = reversed * 10 + (x % 10);
        x /= 10;
    }
    
    return original == reversed;
}
```

#### ğŸ¬ String'siz Ã‡Ã¶zÃ¼m Ã–rneÄŸi

```
x = 121

AdÄ±m adÄ±m ters Ã§evirme:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”‚ x   â”‚ x%10 â”‚ reversed        â”‚ x/10  â”‚
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”‚ 121 â”‚  1   â”‚ 0*10+1 = 1      â”‚  12   â”‚
â”‚  12 â”‚  2   â”‚ 1*10+2 = 12     â”‚   1   â”‚
â”‚   1 â”‚  1   â”‚ 12*10+1 = 121   â”‚   0   â”‚
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

original = 121
reversed = 121
121 == 121  â†’  true âœ…
```

---

### ğŸ“ˆ KarmaÅŸÄ±klÄ±k Analizi

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ String YaklaÅŸÄ±mÄ±                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â±ï¸  Zaman: O(N)                            â”‚
â”‚     â€¢ to_string: O(N)                      â”‚
â”‚     â€¢ For dÃ¶ngÃ¼sÃ¼: O(N/2) â‰ˆ O(N)          â”‚
â”‚                                             â”‚
â”‚ ğŸ’¾ Alan: O(N)                              â”‚
â”‚     â€¢ String iÃ§in N basamak                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Matematiksel YaklaÅŸÄ±m (String'siz)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â±ï¸  Zaman: O(N)                            â”‚
â”‚     â€¢ While dÃ¶ngÃ¼sÃ¼: N basamak             â”‚
â”‚                                             â”‚
â”‚ ğŸ’¾ Alan: O(1)                              â”‚
â”‚     â€¢ Sadece 2-3 deÄŸiÅŸken âš¡               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Ã–zet ve KarÅŸÄ±laÅŸtÄ±rma

### ğŸ“Š ÃœÃ§ Algoritma KarÅŸÄ±laÅŸtÄ±rmasÄ±

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚ Merge Sort   â”‚ Binary Searchâ”‚  Palindrome  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Teknik          â”‚ Divide &     â”‚ Binary Searchâ”‚  Two-Pointer â”‚
â”‚                 â”‚  Conquer     â”‚              â”‚              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Zaman           â”‚ O(N log N)   â”‚ O(log N)     â”‚   O(N)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Alan            â”‚ O(N)         â”‚ O(1)         â”‚ O(N) veya    â”‚
â”‚                 â”‚              â”‚              â”‚   O(1)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Zorluk          â”‚ â­â­â­       â”‚ â­â­         â”‚   â­         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ KullanÄ±m AlanÄ±  â”‚ Genel        â”‚ SÄ±ralÄ±       â”‚ String/      â”‚
â”‚                 â”‚  SÄ±ralama    â”‚  Arama       â”‚  Number      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’¡ Ã–ÄŸrenilen Teknikler

```
ğŸ¯ Merge Sort:
   â”œâ”€ Ã–zyineleme (Recursion) ustasÄ±
   â”œâ”€ BÃ¶l ve Fethet paradigmasÄ±
   â”œâ”€ KararlÄ± (Stable) sÄ±ralama
   â””â”€ Paralelize edilebilir

ğŸ¯ Binary Search:
   â”œâ”€ O(log N) gÃ¼cÃ¼
   â”œâ”€ SÄ±ralÄ± dizilerde hÄ±z
   â”œâ”€ Overflow dikkat!
   â””â”€ Insert position bulma

ğŸ¯ Palindrome Check:
   â”œâ”€ Two-pointer tekniÄŸi
   â”œâ”€ String vs Matematik
   â”œâ”€ Trade-off: Kod vs Bellek
   â””â”€ Edge case'ler (negatif, 0)
```

### âš¡ Performans Ã–zetÄ±

```
Problem Boyutu: N = 1,000,000
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Merge Sort:
  N log N = 1M Ã— 20 â‰ˆ 20,000,000 iÅŸlem
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (sÄ±ralama iÃ§in harika!)

Binary Search:
  log N = 20 iÅŸlem
  â–ˆ (arama iÃ§in mÃ¼kemmel!)

Palindrome:
  N = 1,000,000 basamak (Ã§ok bÃ¼yÃ¼k!)
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (lineer yeterli)
```

---

## ğŸš€ Bonus: Algoritma SeÃ§im Rehberi

```
Hangi algoritmayÄ± ne zaman kullanmalÄ±yÄ±m?
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“¦ Veri sÄ±ralamak mÄ± istiyorsun?
   â””â”€ Merge Sort (kararlÄ±, O(N log N))

ğŸ” SÄ±ralÄ± dizide arama mÄ± yapacaksÄ±n?
   â””â”€ Binary Search (O(log N))

ğŸ”„ String/sayÄ± kontrolÃ¼ mÃ¼?
   â””â”€ Palindrome (Two-pointer, O(N))

âš¡ HÄ±z mÄ± Ã¶nemli, bellek mi?
   â”œâ”€ HÄ±z â†’ Merge Sort (hÄ±zlÄ± ama O(N) alan)
   â””â”€ Bellek â†’ Binary Search (O(1) alan)
```

---

<div align="center">

### ğŸ¯ Happy Coding! ğŸš€

*"Algoritma seÃ§imi, problem Ã§Ã¶zÃ¼mÃ¼nÃ¼n yarÄ±sÄ±dÄ±r."*

---

**ğŸ“š Ä°lgili Konular:**  
Divide & Conquer | Binary Search | Two-Pointer | Recursion | Space-Time Trade-off

</div>